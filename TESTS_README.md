# Curated Graph Benchmark Suite

This file describes the suite of graph pairs generated by the `--gen-suite` command. These tests are designed to stress-test Subgraph Isomorphism algorithms across three dimensions: **Symmetry/Complexity** (Exact), **Scalability** (Approximate), and **Constraint Satisfaction** (Multigraphs).

## 1. Exact Algorithm Tests (Small, N ≈ 10-12)

These tests focus on small graphs with high combinatoric complexity. They are designed to test the correctness of the backtracking engine and its ability to handle symmetry.

### `01_exact_petersen`
*   **Graphs:** Petersen Graph (N=10) vs. Petersen Graph.
*   **Difficulty:** High Symmetry. The Petersen graph has 120 automorphisms. A naive algorithm may revisit equivalent states repeatedly.
*   **Expected Result:** **MATCH**

### `02_exact_clique_11`
*   **Graphs:** Complete Graph K11 vs. K11.
*   **Difficulty:** Worst-Case Branching. Every node connects to every other node. Pruning rules based on topology are ineffective; the algorithm must rely on raw speed or smart ordering.
*   **Expected Result:** **MATCH**

### `03_exact_grid_3x4`
*   **Graphs:** 3x4 Grid vs. 3x4 Grid.
*   **Difficulty:** Regular Topology. The graph has multiple axes of symmetry (corners, edges, center), creating many "almost correct" mappings that fail late.
*   **Expected Result:** **MATCH**

### `04_exact_random_dense_12`
*   **Graphs:** Random (Density=0.6) vs. Identical Copy.
*   **Difficulty:** Unstructured Density. Lacks obvious structural anchors (like high-degree nodes) to bootstrap the search.
*   **Expected Result:** **MATCH**

---

## 2. Approximate Algorithm Tests (Large, N ≈ 50-100)

These tests focus on finding subgraphs within much larger structures. They stress-test heuristics, lookahead, and the ability to avoid local minima in a large search space.

### `05_approx_grid_10x10`
*   **Graphs:** 5x5 Grid (N=25) embedded in 10x10 Grid (N=100).
*   **Difficulty:** Local Optima. A small grid fits locally in many places within a large grid. The algorithm must maintain global consistency without getting lost.
*   **Expected Result:** **MATCH**

### `06_approx_ladder_80`
*   **Graphs:** Ladder Graph (Len=20, N=40) embedded in Ladder Graph (Len=40, N=80).
*   **Difficulty:** Lookahead. The graph is "long and thin". A greedy match at one end might look correct but fail 20 steps later.
*   **Expected Result:** **MATCH**

### `07_approx_binary_tree`
*   **Graphs:** Depth-5 Tree embedded in Depth-6 Tree.
*   **Difficulty:** Hierarchy. Trees are strictly hierarchical. Mapping the root incorrectly invalidates the entire subtree match immediately.
*   **Expected Result:** **MATCH**

### `08_approx_random_dense_60`
*   **Graphs:** N=30 Subgraph embedded in Random Graph (N=60, Density=0.5).
*   **Difficulty:** Noise/Connectivity. The target graph has many edges, making degree-based filtering less effective (many nodes look similar).
*   **Expected Result:** **MATCH**

### `09_approx_sparse_100`
*   **Graphs:** N=40 Subgraph embedded in Sparse Random Graph (N=100, Density=0.08).
*   **Difficulty:** Signal-to-Noise. "Needle in a haystack." The connections are sparse; missing one specific edge breaks the mapping.
*   **Expected Result:** **MATCH**

### `10_approx_massive_star`
*   **Graphs:** Star (N=50) embedded in Star (N=100).
*   **Difficulty:** False Leads. If the algorithm maps the center of G1 to a leaf node in G2, it will fail. It must identify the "hub" correctly.
*   **Expected Result:** **MATCH**

---

## 3. Multigraph Tests (Edge Multiplicity)

These tests specifically target the engine's ability to handle multiple edges (weights) between vertices. `G1 <= G2` requires `Edges(u,v)_G1 <= Edges(map(u), map(v))_G2`.

### `11_multi_arithmetic_clique_10`
*   **Graphs:** K10 where edge weight $(i,j) = (i \cdot j + i + j) \% 20 + 1$.
*   **Difficulty:** Chaos in Symmetry. Topologically, it's a perfect K10 (highly symmetric). However, edge weights are unique "fingerprints." The algorithm must strictly check weights, effectively breaking all symmetry.
*   **Expected Result:** **MATCH**

### `12_multi_heavy_bipartite_20`
*   **Graphs:** K10,10 Bipartite with weights oscillating between 1 and 1000.
*   **Difficulty:** Intensity. Involves thousands of edges. Tests if the algorithm respects edge capacity (e.g., matching a 1000-weight edge to a 1000-weight edge, not a 1-weight edge).
*   **Expected Result:** **MATCH**

### `13_multi_deep_fail_K8`
*   **Graphs:** G1=K8 (one edge wt=50, others 10) vs. G2=K8 (all edges wt=10).
*   **Difficulty:** **Deep Fail.** Topologically identical. The graphs look perfect until the algorithm attempts to map the specific edge pair with weight 50 -> 10. Since 50 > 10, it fails.
*   **Expected Result:** **NO MATCH**

### `14_multi_strength_mismatch`
*   **Graphs:** G1=Heavy Ladder (wt=99) vs. G2=Light Grid (wt=1).
*   **Difficulty:** Strength vs. Topology. G1 is topologically "smaller" (fewer neighbors) but "stronger" (heavy weights). G2 is "larger" but "weaker". Heuristics prioritizing node degree might try to match, but edge constraints must fail it immediately.
*   **Expected Result:** **NO MATCH**

### `15_multi_modulo_ring_12`
*   **Graphs:** Ring 12 where edge weights follow a modulo power sequence ($3^i \% 100$).
*   **Difficulty:** Sequence Matching. A Ring is rotationally symmetric, but the weights dictate a specific alignment. The algorithm must "rotate" G1 until the weight sequence aligns with G2.
*   **Expected Result:** **MATCH**
